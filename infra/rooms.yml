AWSTemplateFormatVersion: "2010-09-09"
Description: >
  Infrastructure for DALVacationHome application.
  Includes SQS FIFO queue, SNS topic, DynamoDB tables, Lambda functions, and API Gateway.

Resources:
  # SQS Queue
  BookingQueue:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: BookingQueue.fifo
      FifoQueue: true
      ContentBasedDeduplication: true

  # SNS Topic
  BookingNotificationsTopic:
    Type: AWS::SNS::Topic
    Properties:
      TopicName: BookingNotifications

  # DynamoDB Tables
  RoomsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: rooms
      AttributeDefinitions:
        - AttributeName: room
          AttributeType: S
      KeySchema:
        - AttributeName: room
          KeyType: HASH
      BillingMode: PAY_PER_REQUEST

  BookingHistoryTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: booking_history
      AttributeDefinitions:
        - AttributeName: bookingid
          AttributeType: S
      KeySchema:
        - AttributeName: bookingid
          KeyType: HASH
      BillingMode: PAY_PER_REQUEST

  # Lambda Functions
  BookingRequestLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: BookingRequestLambda
      Handler: index.lambda_handler
      Role: arn:aws:iam::381492004483:role/LabRole
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          import hashlib

          sqs = boto3.client('sqs')
          QUEUE_URL = os.environ['QUEUE_URL']

          def lambda_handler(event, context):
              try:
                  if 'body' not in event:
                      raise ValueError("Missing 'body' in the event")
                  
                  booking_details = json.loads(event['body'])
                  
                  required_fields = ['email', 'room_id']
                  for field in required_fields:
                      if field not in booking_details:
                          raise ValueError(f"Missing required field: {field}")

                  booking_id = str(uuid.uuid4())
                  booking_details_with_id = {
                      'booking_id': booking_id,
                      'email': booking_details['email'],
                      'room_id': booking_details['room_id']
                  }

                  message_group_id = booking_details['room_id']
                  message_deduplication_id = hashlib.md5(json.dumps(booking_details_with_id).encode('utf-8')).hexdigest()

                  response = sqs.send_message(
                      QueueUrl=QUEUE_URL,
                      MessageBody=json.dumps(booking_details_with_id),
                      MessageGroupId=message_group_id,
                      MessageDeduplicationId: message_deduplication_id
                  )
                  return {
                      'statusCode': 200,
                      'isBase64Encoded': False,
                      'headers': {
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': '*',
                          'Access-Control-Allow-Methods': 'OPTIONS,POST',
                          'Access-Control-Allow-Credentials': True
                      },
                      'body': json.dumps({
                          'message': 'Booking details added to the queue',
                          'messageId': response['MessageId']
                      })
                  }
              except ValueError as ve:
                  return {
                      'statusCode': 400,
                      'isBase64Encoded': False,
                      'headers': {
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': '*',
                          'Access-Control-Allow-Methods': 'OPTIONS,POST',
                          'Access-Control-Allow-Credentials': True
                      },
                      'body': json.dumps({
                          'error': str(ve)
                      })
                  }
              except Exception as e:
                  return {
                      'statusCode': 500,
                      'isBase64Encoded': False,
                      'headers': {
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': '*',
                          'Access-Control-Allow-Methods': 'OPTIONS,POST',
                          'Access-Control-Allow-Credentials': True
                      },
                      'body': json.dumps({
                          'error': 'An error occurred',
                          'details': str(e)
                      })
                  }
      Runtime: python3.8
      Environment:
        Variables:
          QUEUE_URL: !Ref BookingQueue

  BookingValidationLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: BookingValidationLambda
      Handler: index.lambda_handler
      Role: arn:aws:iam::381492004483:role/LabRole
      Code:
        ZipFile: |
          import json
          import boto3
          import os

          dynamodb = boto3.resource('dynamodb')
          sns = boto3.client('sns')

          ROOMS_TABLE_NAME = os.environ['ROOMS_TABLE_NAME']
          BOOKINGS_TABLE_NAME = os.environ['BOOKINGS_TABLE_NAME']
          SNS_TOPIC_ARN = os.environ['SNS_TOPIC_ARN']

          def lambda_handler(event, context):
              rooms_table = dynamodb.Table(ROOMS_TABLE_NAME)
              bookings_table = dynamodb.Table(BOOKINGS_TABLE_NAME)
              
              for record in event['Records']:
                  try:
                      message = json.loads(record['body'])
                      
                      booking_id = message['booking_id']
                      email = message['email']
                      room_id = message['room_id']
                      
                      response = rooms_table.get_item(
                          Key={'room': room_id}
                      )
                      
                      if 'Item' not in response or response['Item']['Availability'] != 'Available':
                          return {
                              'statusCode': 400,
                              'body': json.dumps({
                                  'error': f'Room {room_id} is not available.'
                              })
                          }
                      
                      rooms_table.update_item(
                          Key={'room': room_id},
                          UpdateExpression="set Availability = :a",
                          ExpressionAttributeValues={':a': 'Not Available'}
                      )
                      
                      bookings_table.put_item(
                          Item={
                              'bookingid': booking_id,
                              'email': email,
                              'room_id': room_id,
                              'status': 'Confirmed'
                          }
                      )
                      
                      subject = "Booking Confirmation"
                      body_text = (f"Dear Customer,\n\n"
                                   f"Your booking for room {room_id} has been confirmed.\n"
                                   f"Booking ID: {booking_id}\n\n"
                                   f"Thank you for choosing our service.\n")
                      
                      sns.publish(
                          TopicArn=SNS_TOPIC_ARN,
                          Message=body_text,
                          Subject: subject,
                          MessageAttributes={
                              'email': {
                                  'DataType': 'String',
                                  'StringValue': email
                              }
                          }
                      )
                      
                  except Exception as e:
                      print(f"Error processing record: {record}")
                      print(f"Error message: {str(e)}")
                      return {
                          'statusCode': 500,
                          'body': json.dumps({
                              'error': 'An error occurred',
                              'details': str(e)
                          })
                      }
              
              return {
                  'statusCode': 200,
                  'body': json.dumps('Booking confirmation sent successfully.')
              }
      Runtime: python3.8
      Environment:
        Variables:
          ROOMS_TABLE_NAME: !Ref RoomsTable
          BOOKINGS_TABLE_NAME: !Ref BookingHistoryTable
          SNS_TOPIC_ARN: !Ref BookingNotificationsTopic

  AddRoomLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: AddRoomLambda
      Handler: index.lambda_handler
      Role: arn:aws:iam::381492004483:role/LabRole
      Code:
        ZipFile: |
          import json
          import boto3
          from botocore.exceptions import ClientError

          dynamodb = boto3.resource('dynamodb')
          TABLE_NAME = 'rooms'

          def lambda_handler(event, context):
              try:
                  agent = event['agent']
                  address = event['address']
                  amenities = event['amenities']
                  availability = event['availability']
                  beds = event['beds']
                  room = event['room']
                  price = event['price']
              except KeyError as e:
                  return {
                      'statusCode': 400,
                      'body': json.dumps(f'Missing parameter: {e}')
                  }

              table = dynamodb.Table(TABLE_NAME)

              item = {
                  'Agent': agent,
                  'Address': address,
                  'Amenities': amenities,
                  'Availability': availability,
                  'Beds': beds,
                  'room': room,
                  'Price': price
              }

              try:
                  table.put_item(Item=item)
                  return {
                      'statusCode': 200,
                      'body': json.dumps(f'Room {room} added successfully.')
                  }
              except ClientError as e:
                  return {
                      'statusCode': 500,
                      'body': json.dumps(f'Error adding room: {e.response["Error"]["Message"]}')
                  }
      Runtime: python3.8
      Environment:
        Variables:
          TABLE_NAME: !Ref RoomsTable

  UpdateRoomLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: UpdateRoomLambda
      Handler: index.lambda_handler
      Role: arn:aws:iam::381492004483:role/LabRole
      Code:
        ZipFile: |
          import json
          import boto3
          from botocore.exceptions import ClientError

          dynamodb = boto3.resource('dynamodb')
          TABLE_NAME = 'rooms'

          def lambda_handler(event, context):
              try:
                  room = event['room']
                  update_expression = []
                  expression_attribute_names = {}
                  expression_attribute_values = {}
                  
                  if 'agent' in event:
                      update_expression.append("#a = :agent")
                      expression_attribute_names['#a'] = "Agent"
                      expression_attribute_values[':agent'] = event['agent']
                  
                  if 'address' in event:
                      update_expression.append("#ad = :address")
                      expression_attribute_names['#ad'] = "Address"
                      expression_attribute_values[':address'] = event['address']
                  
                  if 'amenities' in event:
                      update_expression.append("#am = :amenities")
                      expression_attribute_names['#am'] = "Amenities"
                      expression_attribute_values[':amenities'] = event['amenities']
                  
                  if 'availability' in event:
                      update_expression.append("#av = :availability")
                      expression_attribute_names['#av'] = "Availability"
                      expression_attribute_values[':availability'] = event['availability']
                  
                  if 'beds' in event:
                      update_expression.append("#b = :beds")
                      expression_attribute_names['#b'] = "Beds"
                      expression_attribute_values[':beds'] = event['beds']
                  
                  if 'price' in event:
                      update_expression.append("#p = :price")
                      expression_attribute_names['#p'] = "Price"
                      expression_attribute_values[':price'] = event['price']
                  
                  if not update_expression:
                      return {
                          'statusCode': 400,
                          'body': json.dumps('No fields to update.')
                      }

                  update_expression = "SET " + ", ".join(update_expression)
              except KeyError as e:
                  return {
                      'statusCode': 400,
                      'body': json.dumps(f'Missing parameter: {e}')
                  }

              table = dynamodb.Table(TABLE_NAME)

              try:
                  response = table.update_item(
                      Key={'room': room},
                      UpdateExpression=update_expression,
                      ExpressionAttributeNames=expression_attribute_names,
                      ExpressionAttributeValues=expression_attribute_values,
                      ReturnValues="UPDATED_NEW",
                      ConditionExpression="attribute_exists(room)"
                  )
                  return {
                      'statusCode': 200,
                      'body': json.dumps(f'Room {room} updated successfully. {response["Attributes"]}')
                  }
              except ClientError as e:
                  if e.response['Error']['Code'] == 'ConditionalCheckFailedException':
                      return {
                          'statusCode': 404,
                          'body': json.dumps(f'Room {room} not found.')
                      }
                  return {
                      'statusCode': 500,
                      'body': json.dumps(f'Error updating room: {e.response["Error"]["Message"]}')
                  }
      Runtime: python3.8
      Environment:
        Variables:
          TABLE_NAME: !Ref RoomsTable

  DeleteRoomLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: DeleteRoomLambda
      Handler: index.lambda_handler
      Role: arn:aws:iam::381492004483:role/LabRole
      Code:
        ZipFile: |
          import json
          import boto3
          from botocore.exceptions import ClientError

          dynamodb = boto3.resource('dynamodb')
          TABLE_NAME = 'rooms'

          def lambda_handler(event, context):
              try:
                  agent = event['agent']
                  room = event['room']
              except KeyError as e:
                  return {
                      'statusCode': 400,
                      'body': json.dumps(f'Missing parameter: {e}')
                  }

              table = dynamodb.Table(TABLE_NAME)

              try:
                  response = table.delete_item(
                      Key={'room': room}
                  )
                  if 'Attributes' in response:
                      return {
                          'statusCode': 200,
                          'body': json.dumps(f'Room {room} removed successfully.')
                      }
                  else:
                      return {
                          'statusCode': 404,
                          'body': json.dumps(f'Room {room} not found.')
                      }
              except ClientError as e:
                  return {
                      'statusCode': 500,
                      'body': json.dumps(f'Error removing room: {e.response["Error"]["Message"]}')
                  }
      Runtime: python3.8
      Environment:
        Variables:
          TABLE_NAME: !Ref RoomsTable

  EmailNotificationLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: EmailNotificationLambda
      Handler: index.lambda_handler
      Role: arn:aws:iam::381492004483:role/LabRole
      Code:
        ZipFile: |
          import json
          import boto3
          import os

          sns = boto3.client('sns')
          SNS_TOPIC_ARN = os.environ['SNS_TOPIC_ARN']

          def lambda_handler(event, context):
              try:
                  email = event.get('email')
                  message = event.get('message')
                  
                  if not email or not message:
                      raise ValueError("Missing required parameters: 'email' and 'message'")
                  
                  sns_message = {'default': message}
                  
                  response = sns.publish(
                      TopicArn=SNS_TOPIC_ARN,
                      Message=json.dumps(sns_message),
                      Subject="Notification",
                      MessageStructure='json',
                      MessageAttributes={
                          'email': {
                              'DataType': 'String',
                              'StringValue': email
                          }
                      }
                  )
                  
                  return {
                      'statusCode': 200,
                      'isBase64Encoded': False,
                      'headers': {
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': '*',
                          'Access-Control-Allow-Methods': 'OPTIONS,POST',
                          'Access-Control-Allow-Credentials': True
                      },
                      'body': json.dumps({
                          'message': 'Notification sent successfully',
                          'messageId': response['MessageId']
                      })
                  }
              except ValueError as ve:
                  return {
                      'statusCode': 400,
                      'isBase64Encoded': False,
                      'headers': {
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': '*',
                          'Access-Control-Allow-Methods': 'OPTIONS,POST',
                          'Access-Control-Allow-Credentials': True
                      },
                      'body': json.dumps({'error': str(ve)})
                  }
              except Exception as e:
                  return {
                      'statusCode': 500,
                      'isBase64Encoded': False,
                      'headers': {
                          'Access-Control-Allow-Origin': '*',
                          'Access-Control-Allow-Headers': '*',
                          'Access-Control-Allow-Methods': 'OPTIONS,POST',
                          'Access-Control-Allow-Credentials': True
                      },
                      'body': json.dumps({
                          'error': 'An error occurred',
                          'details': str(e)
                      })
                  }
      Runtime: python3.8
      Environment:
        Variables:
          SNS_TOPIC_ARN: !Ref BookingNotificationsTopic

  # API Gateway
  ApiGateway:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: DALVacationHomeApi

  # Resources
  AuthResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      ParentId: !GetAtt ApiGateway.RootResourceId
      PathPart: auth
      RestApiId: !Ref ApiGateway

  BookingResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      ParentId: !GetAtt ApiGateway.RootResourceId
      PathPart: booking
      RestApiId: !Ref ApiGateway

  RoomResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      ParentId: !GetAtt ApiGateway.RootResourceId
      PathPart: room
      RestApiId: !Ref ApiGateway

  # Methods for /booking
  BookingMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      AuthorizationType: NONE
      HttpMethod: POST
      ResourceId: !Ref BookingResource
      RestApiId: !Ref ApiGateway
      Integration:
        IntegrationHttpMethod: POST
        Type: AWS_PROXY
        Uri: !Sub
          - arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${BookingRequestLambdaArn}/invocations
          - BookingRequestLambdaArn: !GetAtt BookingRequestLambda.Arn

  # BookingMethodOptions:
  #   Type: AWS::ApiGateway::Method
  #   Properties:
  #     AuthorizationType: NONE
  #     HttpMethod: OPTIONS
  #     ResourceId: !Ref BookingResource
  #     RestApiId: !Ref ApiGateway
  #     Integration:
  #       IntegrationResponses:
  #         - StatusCode: 200
  #           ResponseParameters:
  #             method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
  #             method.response.header.Access-Control-Allow-Origin: "'*'"
  #             method.response.header.Access-Control-Allow-Methods: "'OPTIONS,POST'"
  #       RequestTemplates:
  #         application/json: '{"statusCode": 200}'
  #       PassthroughBehavior: WHEN_NO_MATCH
  #       Type: MOCK
  #     MethodResponses:
  #       - StatusCode: 200
  #         ResponseParameters:
  #           method.response.header.Access-Control-Allow-Headers: true
  #           method.response.header.Access-Control-Allow-Methods: true
  #           method.response.header.Access-Control-Allow-Origin: true

  # Methods for /room
  AddRoomMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      AuthorizationType: NONE
      HttpMethod: POST
      ResourceId: !Ref RoomResource
      RestApiId: !Ref ApiGateway
      Integration:
        IntegrationHttpMethod: POST
        Type: AWS_PROXY
        Uri: !Sub
          - arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${AddRoomLambdaArn}/invocations
          - AddRoomLambdaArn: !GetAtt AddRoomLambda.Arn

  # AddRoomMethodOptions:
  #   Type: AWS::ApiGateway::Method
  #   Properties:
  #     AuthorizationType: NONE
  #     HttpMethod: OPTIONS
  #     ResourceId: !Ref RoomResource
  #     RestApiId: !Ref ApiGateway
  #     Integration:
  #       IntegrationResponses:
  #         - StatusCode: 200
  #           ResponseParameters:
  #             method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
  #             method.response.header.Access-Control-Allow-Origin: "'*'"
  #             method.response.header.Access-Control-Allow-Methods: "'OPTIONS,POST'"
  #       RequestTemplates:
  #         application/json: '{"statusCode": 200}'
  #       PassthroughBehavior: WHEN_NO_MATCH
  #       Type: MOCK
  #     MethodResponses:
  #       - StatusCode: 200
  #         ResponseParameters:
  #           method.response.header.Access-Control-Allow-Headers: true
  #           method.response.header.Access-Control-Allow-Methods: true
  #           method.response.header.Access-Control-Allow-Origin: true

  UpdateRoomMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      AuthorizationType: NONE
      HttpMethod: PUT
      ResourceId: !Ref RoomResource
      RestApiId: !Ref ApiGateway
      Integration:
        IntegrationHttpMethod: PUT
        Type: AWS_PROXY
        Uri: !Sub
          - arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${UpdateRoomLambdaArn}/invocations
          - UpdateRoomLambdaArn: !GetAtt UpdateRoomLambda.Arn

  # UpdateRoomMethodOptions:
  #   Type: AWS::ApiGateway::Method
  #   Properties:
  #     AuthorizationType: NONE
  #     HttpMethod: OPTIONS
  #     ResourceId: !Ref RoomResource
  #     RestApiId: !Ref ApiGateway
  #     Integration:
  #       IntegrationResponses:
  #         - StatusCode: 200
  #           ResponseParameters:
  #             method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
  #             method.response.header.Access-Control-Allow-Origin: "'*'"
  #             method.response.header.Access-Control-Allow-Methods: "'OPTIONS,PUT'"
  #       RequestTemplates:
  #         application/json: '{"statusCode": 200}'
  #       PassthroughBehavior: WHEN_NO_MATCH
  #       Type: MOCK
  #     MethodResponses:
  #       - StatusCode: 200
  #         ResponseParameters:
  #           method.response.header.Access-Control-Allow-Headers: true
  #           method.response.header.Access-Control-Allow-Methods: true
  #           method.response.header.Access-Control-Allow-Origin: true

  DeleteRoomMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      AuthorizationType: NONE
      HttpMethod: DELETE
      ResourceId: !Ref RoomResource
      RestApiId: !Ref ApiGateway
      Integration:
        IntegrationHttpMethod: DELETE
        Type: AWS_PROXY
        Uri: !Sub
          - arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${DeleteRoomLambdaArn}/invocations
          - DeleteRoomLambdaArn: !GetAtt DeleteRoomLambda.Arn

  # DeleteRoomMethodOptions:
  #   Type: AWS::ApiGateway::Method
  #   Properties:
  #     AuthorizationType: NONE
  #     HttpMethod: OPTIONS
  #     ResourceId: !Ref RoomResource
  #     RestApiId: !Ref ApiGateway
  #     Integration:
  #       IntegrationResponses:
  #         - StatusCode: 200
  #           ResponseParameters:
  #             method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
  #             method.response.header.Access-Control-Allow-Origin: "'*'"
  #             method.response.header.Access-Control-Allow-Methods: "'OPTIONS,DELETE'"
  #       RequestTemplates:
  #         application/json: '{"statusCode": 200}'
  #       PassthroughBehavior: WHEN_NO_MATCH
  #       Type: MOCK
  #     MethodResponses:
  #       - StatusCode: 200
  #         ResponseParameters:
  #           method.response.header.Access-Control-Allow-Headers: true
  #           method.response.header.Access-Control-Allow-Methods: true
  #           method.response.header.Access-Control-Allow-Origin: true

Outputs:
  ApiGatewayUrl:
    Description: URL of the API Gateway
    Value: !Sub "https://${ApiGateway}.execute-api.${AWS::Region}.amazonaws.com/prod/"
  BookingQueueUrl:
    Description: URL of the Booking SQS Queue
    Value: !Ref BookingQueue
  RoomsTableName:
    Description: Name of the Rooms DynamoDB Table
    Value: !Ref RoomsTable
  BookingHistoryTableName:
    Description: Name of the Booking History DynamoDB Table
    Value: !Ref BookingHistoryTable
  BookingRequestLambdaArn:
    Description: ARN of the Booking Request Lambda Function
    Value: !GetAtt BookingRequestLambda.Arn
  BookingValidationLambdaArn:
    Description: ARN of the Booking Validation Lambda Function
    Value: !GetAtt BookingValidationLambda.Arn
  AddRoomLambdaArn:
    Description: ARN of the Add Room Lambda Function
    Value: !GetAtt AddRoomLambda.Arn
  UpdateRoomLambdaArn:
    Description: ARN of the Update Room Lambda Function
    Value: !GetAtt UpdateRoomLambda.Arn
  DeleteRoomLambdaArn:
    Description: ARN of the Delete Room Lambda Function
    Value: !GetAtt DeleteRoomLambda.Arn
  EmailNotificationLambdaArn:
    Description: ARN of the Email Notification Lambda Function
    Value: !GetAtt EmailNotificationLambda.Arn
